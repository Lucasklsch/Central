<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris WebGL</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0f14;color:#e7eef7;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{display:grid;place-items:center;height:100%;gap:16px;padding:16px}
    canvas{width:min(90vw,480px);height:min(90vh,800px);aspect-ratio:9/16;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);background:#0a0a12}
    .hud{display:flex;gap:16px;flex-wrap:wrap;align-items:center;justify-content:center}
    .pill{background:#121826;padding:8px 12px;border-radius:999px;font-size:14px;opacity:.9}
    .title{font-weight:700;letter-spacing:.2px}
    .btn{cursor:pointer;background:#1d283a;border:none;color:#dbe9ff;padding:8px 12px;border-radius:10px}
    .btn:active{transform:translateY(1px)}
    a{color:#a8d1ff}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <span class="pill title">Tetris WebGL</span>
      <span class="pill">← → mover</span>
      <span class="pill">↑ girar</span>
      <span class="pill">↓ descer</span>
      <span class="pill">Espaço: queda</span>
      <span class="pill">P: pausar</span>
      <span class="pill">R: reiniciar</span>
      <button class="btn" id="reset">Reiniciar</button>
    </div>
    <canvas id="gl" width="360" height="640"></canvas>
    <div class="hud" id="info"></div>
  </div>

<script>
(() => {
  // ---- Game constants ----
  const COLS = 10, ROWS = 20; // Board size
  const BLOCK = 32;           // Virtual block size (for projection only)
  const GRAVITY_START = 0.9;  // Seconds per row at level 1
  const LEVEL_UP_LINES = 10;

  // Tetromino definitions (relative cell coords)
  const SHAPES = {
    I: { c: [ [0,1],[1,1],[2,1],[3,1] ], color: [0.25,0.80,0.90] },
    J: { c: [ [0,0],[0,1],[1,1],[2,1] ], color: [0.30,0.55,0.95] },
    L: { c: [ [2,0],[0,1],[1,1],[2,1] ], color: [0.95,0.65,0.25] },
    O: { c: [ [1,0],[2,0],[1,1],[2,1] ], color: [0.98,0.85,0.25] },
    S: { c: [ [1,0],[2,0],[0,1],[1,1] ], color: [0.40,0.85,0.40] },
    T: { c: [ [1,0],[0,1],[1,1],[2,1] ], color: [0.80,0.45,0.95] },
    Z: { c: [ [0,0],[1,0],[1,1],[2,1] ], color: [0.95,0.35,0.40] }
  };
  const TYPES = Object.keys(SHAPES);

  function rotateRight(cells){
    // rotate around origin: (x,y) -> (y, -x)
    let maxX = Math.max(...cells.map(p=>p[0]));
    let rotated = cells.map(([x,y])=>[y, -x]);
    // shift so min x/y >= 0
    let minX = Math.min(...rotated.map(p=>p[0]));
    let minY = Math.min(...rotated.map(p=>p[1]));
    rotated = rotated.map(([x,y])=>[x - minX, y - minY]);
    return rotated;
  }

  // ---- PRNG bag for fair pieces ----
  class Bag {
    constructor(){ this.bag = []; }
    next(){
      if(!this.bag.length) this.bag = TYPES.slice().sort(()=>Math.random()-0.5);
      return this.bag.pop();
    }
  }

  // ---- Game state ----
  const bag = new Bag();
  let board = makeBoard();
  let cur = spawn();
  let dropTimer = 0;
  let gravity = GRAVITY_START;
  let score = 0, lines = 0, level = 1;
  let paused = false, over = false;

  function makeBoard(){
    // Each cell: [r,g,b,filled]
    const arr = new Array(ROWS);
    for(let y=0;y<ROWS;y++){
      arr[y] = new Array(COLS).fill(0).map(()=>[0,0,0,0]);
    }
    return arr;
  }

  function spawn(){
    const t = bag.next();
    const s = SHAPES[t];
    const cells = s.c.map(([x,y])=>[x,y]);
    const x = Math.floor((COLS-4)/2), y = 0;
    return { type:t, cells, x, y, color:s.color };
  }

  function testCollision(nx, ny, ncells){
    for(const [cx,cy] of ncells){
      const gx = nx + cx;
      const gy = ny + cy;
      if(gx<0||gx>=COLS||gy<0||gy>=ROWS) return true;
      if(board[gy][gx][3]) return true;
    }
    return false;
  }

  function lockPiece(){
    for(const [cx,cy] of cur.cells){
      const gx = cur.x + cx;
      const gy = cur.y + cy;
      if(gy<0){ over = true; return; }
      board[gy][gx] = [...cur.color, 1];
    }
    // Clear lines
    let cleared = 0;
    outer: for(let y=ROWS-1;y>=0;){
      if(board[y].every(c=>c[3])){ board.splice(y,1); board.unshift(new Array(COLS).fill(0).map(()=>[0,0,0,0])); cleared++; }
      else y--;
    }
    if(cleared){
      const points = [0,40,100,300,1200][cleared] * level; // classic-like
      score += points; lines += cleared;
      if(lines >= level*LEVEL_UP_LINES){ level++; gravity = Math.max(0.1, GRAVITY_START * Math.pow(0.85, level-1)); }
    }
    cur = spawn();
    if(testCollision(cur.x, cur.y, cur.cells)) over = true;
  }

  // ---- Input ----
  const keys = new Set();
  document.addEventListener('keydown', (e)=>{
    if(e.code==='ArrowLeft'){ e.preventDefault(); tryMove(-1,0); }
    else if(e.code==='ArrowRight'){ e.preventDefault(); tryMove(1,0); }
    else if(e.code==='ArrowDown'){ e.preventDefault(); softDrop(); }
    else if(e.code==='ArrowUp'){ e.preventDefault(); tryRotate(); }
    else if(e.code==='Space'){ e.preventDefault(); hardDrop(); }
    else if(e.code==='KeyP'){ paused = !paused; }
    else if(e.code==='KeyR'){ reset(); }
  });
  document.getElementById('reset').onclick = reset;

  function tryMove(dx,dy){
    if(over||paused) return;
    if(!testCollision(cur.x+dx, cur.y+dy, cur.cells)) { cur.x+=dx; cur.y+=dy; }
  }
  function softDrop(){ if(over||paused) return; if(!testCollision(cur.x, cur.y+1, cur.cells)) cur.y++; else lockPiece(); score++; }
  function hardDrop(){ if(over||paused) return; while(!testCollision(cur.x, cur.y+1, cur.cells)) { cur.y++; score+=2; } lockPiece(); }
  function tryRotate(){
    if(over||paused) return;
    const rc = rotateRight(cur.cells);
    // simple wall kicks: try offsets
    const kicks = [[0,0],[-1,0],[1,0],[-2,0],[2,0],[0,-1]];
    for(const [kx,ky] of kicks){
      if(!testCollision(cur.x+kx, cur.y+ky, rc)) { cur.cells = rc; cur.x+=kx; cur.y+=ky; return; }
    }
  }
  function reset(){ board = makeBoard(); cur = spawn(); dropTimer=0; gravity=GRAVITY_START; score=0; lines=0; level=1; paused=false; over=false; }

  // ---- WebGL setup ----
  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl2');
  if(!gl){ alert('WebGL2 não suportado.'); return; }

  // Vertex shader: draws a unit square per instance, positioned by instance attributes
  const vs = `#version 300 es
  layout(location=0) in vec2 aPos;            // base quad (-0.5..0.5)
  layout(location=1) in vec2 iCell;           // cell grid position
  layout(location=2) in vec3 iColor;          // color
  uniform vec2 uGridSize;                     // cols, rows
  uniform vec2 uCanvas;                       // pixel size
  out vec3 vColor;
  void main(){
    // Convert grid cell to NDC
    vec2 cellSize = vec2(2.0/uGridSize.x, 2.0/uGridSize.y);
    vec2 offset = vec2(-1.0 + cellSize.x*(iCell.x + 0.5), 1.0 - cellSize.y*(iCell.y + 0.5));
    // aPos is -0.5..0.5 unit square scaled to cellSize
    vec2 pos = offset + aPos * cellSize * 0.92; // 0.92 = padding for gap
    gl_Position = vec4(pos, 0.0, 1.0);
    vColor = iColor;
  }`;

  const fs = `#version 300 es
  precision mediump float;
  in vec3 vColor;
  out vec4 outColor;
  void main(){ outColor = vec4(vColor, 1.0); }`;

  function compile(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
  function program(vsSrc, fsSrc){ const p = gl.createProgram(); gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc)); gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc)); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p)); return p; }

  const prog = program(vs, fs);
  gl.useProgram(prog);
  const uGridSize = gl.getUniformLocation(prog, 'uGridSize');

  // Base quad (two triangles) in -0.5..0.5 space
  const quad = new Float32Array([
    -0.5,-0.5,  0.5,-0.5,  0.5, 0.5,
    -0.5,-0.5,  0.5, 0.5, -0.5, 0.5,
  ]);
  const quadVBO = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
  gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

  // Instance buffers: iCell (vec2), iColor (vec3)
  const MAX_INSTANCES = COLS*ROWS + 16; // board + current piece
  const cellData = new Float32Array(MAX_INSTANCES*2);
  const colorData = new Float32Array(MAX_INSTANCES*3);
  const cellVBO = gl.createBuffer();
  const colorVBO = gl.createBuffer();

  function enableInstancedAttrib(buffer, loc, size, divisor){
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
    gl.vertexAttribDivisor(loc, divisor);
  }
  enableInstancedAttrib(cellVBO, 1, 2, 1);
  enableInstancedAttrib(colorVBO, 2, 3, 1);

  gl.clearColor(0.03,0.04,0.08,1);

  function collectInstances(){
    let n = 0;
    // Board
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const c = board[y][x];
        if(c[3]){
          cellData[n*2+0] = x; cellData[n*2+1] = y;
          colorData[n*3+0] = c[0]; colorData[n*3+1] = c[1]; colorData[n*3+2] = c[2];
          n++;
        }
      }
    }
    // Current piece
    for(const [cx,cy] of cur.cells){
      const x = cur.x + cx, y = cur.y + cy;
      if(y>=0){
        cellData[n*2+0] = x; cellData[n*2+1] = y;
        colorData[n*3+0] = cur.color[0]; colorData[n*3+1] = cur.color[1]; colorData[n*3+2] = cur.color[2];
        n++;
      }
    }
    // Ghost piece (faded)
    let gy = cur.y; while(!testCollision(cur.x, gy+1, cur.cells)) gy++;
    for(const [cx,cy] of cur.cells){
      const x = cur.x + cx, y = gy + cy;
      if(y>=0){
        cellData[n*2+0] = x; cellData[n*2+1] = y;
        colorData[n*3+0] = cur.color[0]*0.35; colorData[n*3+1] = cur.color[1]*0.35; colorData[n*3+2] = cur.color[2]*0.35;
        n++;
      }
    }
    return n;
  }

  function render(){
    gl.viewport(0,0,gl.canvas.width, gl.canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(prog);
    gl.uniform2f(uGridSize, COLS, ROWS);

    const count = collectInstances();
    gl.bindBuffer(gl.ARRAY_BUFFER, cellVBO);
    gl.bufferData(gl.ARRAY_BUFFER, cellData.subarray(0, count*2), gl.DYNAMIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorVBO);
    gl.bufferData(gl.ARRAY_BUFFER, colorData.subarray(0, count*3), gl.DYNAMIC_DRAW);

    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, count);
  }

  // ---- Loop ----
  let last = performance.now();
  function loop(now){
    const dt = (now - last) / 1000; last = now;
    document.getElementById('info').innerHTML = `Pontuação: <b>${score}</b> · Linhas: <b>${lines}</b> · Nível: <b>${level}</b>${over? ' · <b>GAME OVER</b>':''}${paused? ' · <b>PAUSADO</b>':''}`;
    if(!paused && !over){
      dropTimer += dt;
      if(dropTimer >= gravity){ dropTimer = 0; if(!testCollision(cur.x, cur.y+1, cur.cells)) cur.y++; else lockPiece(); }
    }
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
